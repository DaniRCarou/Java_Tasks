package model.entity;

import jakarta.persistence.Entity;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.persistence.Temporal;
import jakarta.persistence.TemporalType;

/*
 
 - The @Entity and @Table annotations are crucial for mapping ("Mapping" in the context of programming, especially when talking about databases and ORM (Object-Relational Mapping), 
 refers to the process of establishing a correspondence or connection between two different structures, 
 typically between objects in a program and tables in a relational database.) Java classes to tables in a relational database. 
 These annotations are part of the JPA specification and are used to define how a class is mapped to a database table. 

*/



// The class must follow the JavaBean convention in order to be an entity. It must have a public no-argument constructor (default constructor), private attributes and public get and set methods.
// With this annotation, it is indicated that this class will be a database table. By default, the table will be named after the class in lowerCamelCase (author).
@Entity


// The @Table annotation in JPA (Java Persistence API) is used to specify the table in the database that an entity class is mapped to. 
// This annotation is part of the JPA standard and helps define the relationship between the entity class and the corresponding database table.
@Table(name="Authors")


public class Author {
	
	
	
	// All tables should have a unique identifier. With @Id it is indicated that the attribute id would be a primary key. Name could be a primary key. We have to use @Id
	@Id		
	//
	// The @GeneratedValue annotation in JPA (Java Persistence API) is used to specify how the values for a primary key field or property are generated. 
	// It is commonly used in conjunction with the @Id annotation to indicate that the primary key value is automatically generated by the persistence provider, rather than being assigned manually.
	// The @GeneratedValue(strategy = GenerationType.IDENTITY) annotation in JPA specifies that the primary key values should be automatically generated by the database using an identity column. 
	// This strategy is commonly used when you want the database to handle the generation of unique primary key values, often through an auto-increment feature.
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	
	// The others attributes will be regular fields in the database.	
	private String name;	
	private String surname;
	
	// It has to be indicated to JPA, that this attribute of type DATE must be mapped as a date with the following annotation: @Temporal(TemporalType.DATE)
	// @Temporal(TemporalType.TIME) -> It will save only the hour, minutes......
	// @Temporal(TemporalType.TIMESTAPM) -> It will save both, Date and time.
	@Temporal(TemporalType.DATE) // Format: 01/09/2024
	private Date birthday; // Date is imported from java.util	
	
	
	
	
	// With this annotation, we will make the entities have bidirectional relationships. 
	// In this case, an Author can have many books, so the "@OneToMany" annotation will be needed.
	// Since it is required that the Book class has access to the Author class and vice versa(bidirectional relationship), we will also add the OneToMany annotation here.
	// In a bidirectional relationship, the @OneToMany annotation is typically used on the "one" side of a one-to-many relationship, indicating that one entity is related to many entities. 
	// The @ManyToOne annotation is used on the "many" side to define the relationship from that perspective.
	//
	// MappedBy -> With this attribute, we specify which of the possible authors we are relating to. IN THE BOOK CLASS THERE IS ONLY ONE Author. 
	// For example, in a joint bank account, there could be two registered clients: private Cliente cliente1 and private Cliente cliente2.
	@OneToMany(mappedBy = "author")
	private List<Book> books;
	
		public Author() {
		super();
	}	
	
	
	
	public int getId() {
		return id;
	}


	public void setId(int id) {
		this.id = id;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}


	public String getSurname() {
		return surname;
	}


	public void setSurname(String surname) {
		this.surname = surname;
	}


	public Date getBirthday() {
		return birthday;
	}


	public void setBirthday(int day, int month, int year) {
		
	/*
		A new instance of the Calendar class is obtained, which represents a calendar with the current date and time. 
		The Calendar class does not have a direct constructor, so to create a new Calendar object, you must use a method like getInstance(). 
		Although getInstance() returns a Calendar with the current date and time, the day, month, and year values are then overwritten with those passed as parameters to the method. 
		In other words, the initial date and time don't really matter, as they are immediately modified with the set(year, month - 1, day) method.
	*/	
		Calendar calendar = Calendar.getInstance();
		
	/*	
		Here, the values for year, month, and day are set in the Calendar object.
		Important: The Calendar class in Java starts counting months from 0 (January = 0, February = 1, ..., December = 11). 
		Thatâ€™s why 1 is subtracted from the month value to adjust it to this format.
	*/
		calendar.set(year, month - 1, day);
		
	/*	
		Finally, the getTime() method converts the Calendar object into an instance of the Date class.
		That date (a Date object) is assigned to the instance variable birthday of the current object (this), 
		which presumably represents the birthday of some object.
	*/
		this.birthday = calendar.getTime();
		
	}



	public void setBooks(List<Book> books) {
		this.books = books;
	}



	@Override
	public String toString() {
		return "Author: id=" + id + "\nname=" + name + "\nsurname=" + surname + "\nbirthday=" + birthday + "\nbooks="
				+ books + "";
	}


	
	
	
		
	

}
